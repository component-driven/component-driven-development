import { jsx, Flex, Box } from 'theme-ui';
import {
	Appear,
	Boom,
	Center,
	Code,
	Cover,
	Image,
	Notes,
	LiveCode,
	List,
	Primary,
	Secondary,
	SplitWithHeading,
	ThatGuy,
} from './theme';
import { Prism } from 'react-syntax-highlighter';
import TweetEmbed from 'react-tweet-embed';
import Stack from 'stack-styled';
import * as dropdown from './code/dropdown.js';

export { theme } from './theme';

<Cover author="Andrey Okonetchnikov">

# Resilient Component Libraries with React

</Cover>

---

<Center>

# My name is Andrey

I design & develop user interfaces on the Web since 1999

</Center>

---

<Secondary>

# User Interface Design & Development

</Secondary>

---

<Image src="../assets/wireframe.jpg" size="contain" />

---

### How to build a UI

1. Get a static mockup from a designer
1. Write HTML markup that represents the mockup
1. Write CSS and connect with HTML using classes
1. "Sprinkle" JavaScript using classes to add interactivity
1. Hand off to a backend developer
1. Replace HTML with PHP, Ruby, Java, ...
1. ...
1. Profit

---

<Center>

Fast forward 20 years...

</Center>

---

### How to build a UI with React

1. Get a static mockup from a designer
1. Get data from API endpoint
1. Render data in JSX using HTML
1. Write CSS and connect with JSX using `className`
1. ...
1. Profit

---

<Secondary>

> Designers are still drawing **static mockups** and developers are writing **HTML & CSS**

</Secondary>

---

<Secondary>

# What's the problem with static mockups?

</Secondary>

---

<Image src="./assets/dribbble1.png" size="contain" />

---

<Image src="./assets/dribbble2.png" size="contain" />

---

## Static mockups...

- not covering all possible states
- not covering all possible resolutions
- losing lots of design knowledge during ~~translation~~ hand-off
- are static!

---

<Boom>

## Mockups are **static**

## Applications are **dynamic**

</Boom>

---

<Secondary>

## Why building your own component library?

</Secondary>

---

<Secondary>

## What's the problem with HTML?

</Secondary>

---

<Boom>

> HTML was designed for documents, not applications!

</Boom>

---

<Stack gridGap={5} p={4} gridTemplateColumns="auto 1fr auto">
	<span>Text, Heading</span>
	<Code language="html">{`<h1>Heading</h1>
<p>Text</p>`}</Code>
	<span>️😊</span>
	<span>Link</span>
	<Code language="html">{`<a href="#">Link</a>`}</Code>
	<span>🤔</span>
	<span>Button</span>
	<Code language="html">
		{`<button>Button</button>
<input type="button">Button</input>`}
	</Code>
	<span>🙄</span>
	<span>Dropdown</span>
	<Code language="html">{dropdown.html}</Code>
	<span>😩</span>
</Stack>

---

<Image src="./assets/bootstrap-dropdown.png" size="contain" />

<ThatGuy />

---

<Secondary>

# Is there a better way?

</Secondary>

---

<Boom>

> Components is a better way of writing HTML

</Boom>

---

<Center>

# Components

- `<Button>` → `<button>`
- `<Input>` → `<input type="text">`
- `<Checkbox>` → `<input type="checkbox">`
- `<Dropdown>` → ~~`<select>`~~ `<div class="dropdown">...`

</Center>

---

<SplitWithHeading>

## HTML & CSS vs Primitives

<Code language="html">{dropdown.html}</Code>

<Code language="jsx">{dropdown.jsx}</Code>

</SplitWithHeading>

---

<SplitWithHeading>

## Components can change over time

```jsx harmony
const Dropdown = props => (
	<select>
		{props.options.map(option => (
			<option>{option}</option>
		))}
	</select>
);
```

```jsx harmony
const Dropdown = props => (
	<div className="dropdown">
		<button class="btn btn-dropdown">{props.button}</button>
		<ul>
			{props.options.map(option => (
				<li>{option}</li>
			))}
		</ul>
	</div>
);
```

</SplitWithHeading>

---

# Components as a common language

<Stack gridGap={5} p={4} gridTemplateColumns="1fr 1fr">
	<span>A button</span>
	<Code language="jsx">{`<Button>`}</Code>
	<span>A primary button</span>
	<Code language="jsx">{`<Button primary>`}</Code>
	<span>A cheked checkbox</span>
	<Code language="jsx">{`<Checkbox checked>`}</Code>
	<span>A product card</span>
	<Code language="jsx">{`<ProductCard>`}</Code>
</Stack>

---

<Boom>

> Components as a common UI language

</Boom>

---

<Boom>

> Do not use verbs when naming components

</Boom>

---

## Watch my talk

---

<Secondary>

## `Button > button`

<Appear>

## `Text > p`

## `Heading > h1`

</Appear>

</Secondary>

---

<Secondary>

## What's the problem with CSS?

</Secondary>

---

<Boom>

# CSS is hard 🤯

</Boom>

---

<Center>
	<TweetEmbed id="1038073603311448064" />
	<ThatGuy />
</Center>

---

<Center>

# CSS is the source of inconsistent UIs

</Center>

---

<Image src="./assets/doors.jpg" />

---

## Sources of inconsistent UIs

- Color & Typography → Custom CSS
- Spacing & Layout → Custom CSS

---

<SplitWithHeading>

## Custom CSS

```css
.description {
	margin-bottom: 20px;
	font-size: 16px;
	color: #c9b8b9;
}
```

```css
.count {
	margin-left: 0.75em;
	font-size: 14px;
	opacity: 0.5;
	color: #fc9;
}
```

</SplitWithHeading>

---

<Image src="./assets/too-many-buttons.jpg" size="contain" />

---

<Image src="./assets/too-many-buttons-2.jpg" size="contain" />

---

<Image src="./assets/text.png" size="contain" />

---

<Boom>

# CSS is too expressive 👩‍🎨

</Boom>

---

<Primary>

# Design tokens

</Primary>

---

<Center>
	<Image src="./assets/dls-foundation.png" size="contain" />
</Center>

---

<Center>
	<a href="https://marvelapp.com/styleguide/design/color-scheme">
		<img src="../assets/design-tokens-colors.png" alt="Design tokens: colors" />
	</a>
</Center>

---

<Center>
	<a href="https://cloudflare.github.io/cf-ui/#cf-design-gradients">
		<img
			src="../assets/design-tokens-gradients.png"
			alt="Design tokens: gradients"
		/>
	</a>
</Center>

---

<Center>
	<a href="https://vueds.com/example/#!/Design%20Tokens">
		<img
			src="../assets/design-tokens-fonts-spacing.png"
			alt="Design tokens: fonts and spacing"
		/>
	</a>
</Center>

---

<Center>
	<a href="https://www.lightningdesignsystem.com/design-tokens/">
		<img src="../assets/design-tokens-misc.png" alt="Design tokens" />
	</a>
</Center>

---

<Boom>

> Design tokens are everything you use more than once in your styles

</Boom>

---

<SplitWithHeading>

## Custom properties as design tokens

```css
.description {
	margin-bottom: var(--spacing--3);
	font-size: var(--fontSize--base);
	color: var(--color-grey);
}
```

```css
.count {
	margin-left: var(--spacing--2);
	font-size: var(--fontSize--small);
	color: var(--color--light);
}
```

</SplitWithHeading>

---

## Custom properties as design tokens

- improve code reusabilty
- but still allow wrong combinations
- hard to enforce on scale
- require writing CSS

---

<Secondary>

What should we do?

</Secondary>

---

<Boom>

# Stop writing CSS!

</Boom>

---

<Primary>

# Primitive components

</Primary>

---

<Image src="../assets/legos.jpg" />

---

<Boom>

> Primitives are the building blocks of the user interface.

</Boom>

---

<Image src="../assets/legos-assembled.jpg" />

---

<Center>

<Code language="jsx">{`<Button onClick={handleClick} />`}</Code>

</Center>

---

<Center>

<Code language="jsx">{`<Text fontSize="lg" color="danger" />`}</Code>

</Center>

---

<Primary>

# Text Primitives

</Primary>

---

## Text styles

<ul>
	<li>Normal text</li>
	<li style={{ color: '#979797', fontSize: '80%' }}>Secondary text</li>
	<li style={{ color: '#930' }}>Error</li>
	<li>etc.</li>
</ul>

---

## API:

- Text style (`color`, `fontSize`, `letterSpacing`, etc.)
- Alignment (`left`, `center`, `right`, ~~`justify`~~)
- Whitespace (`margin`)
- HTML elements (`p`, `span`, `label`)

---

<Boom>

> Define a minimal set of props for most of your use cases

</Boom>

---

## API: boolean vs variant

- `<Text primary>` 😀
- `<Text secondary>` 😀
- `<Text primary secondary>` 🤯

---

## API: boolean vs variant

- `<Text variant="primary">` 😀
- `<Text variant="secondary">` 😀
- ~~`<Text variant="primary secondary">`~~ 🚫

---

## API: boolean vs variant

- `<Button variant="primary" disabled>` 😀
- `<Button variant="secondary" disabled>` 😀

---

<Boom>

> Variants make impossible states impossible

</Boom>

---

## API: rigidity vs flexibility

- `<Text variant="error">` 😀
- `<Text color="red" size="xs">` 😀
- `<Text variant="muted" sx={{ letterSpacing: 'caps' }} >` 🤓

---

<Boom>

> Make primitives flexible enough to not block you

</Boom>

---

## API: HTML element

- `<Text>` → `<p>` 😀
- `<Text inline>` → `<span>` 😐
- `<Text label>` → `<label>` 😭
- `<Text as="label">` → `<label>` 😀

---

<Boom>

> Primitives can be rendered anywhere

</Boom>

---

## API: Composition

- `<Heading>` → `<Text variant="heading" as="h1">`
- `<Label>` → `<Text variant="label" as="label">`
- `<Error>` → `<Text color="error" as="p">`

---

<Boom>

> Primitives are meant to be composed

</Boom>

---

<LiveCode
	title="Example"
	code={require('!raw-loader!./code/Text.js').default}
	size="fullscreen"
/>

---

<LiveCode
	title="Example"
	code={require('!raw-loader!./code/Text2.js').default}
	size="fullscreen"
/>

---

<Primary>

# Layout Primitives

</Primary>

---

<Boom>

> Primitives to control space around their children

</Boom>

---

<Secondary>

# Box

</Secondary>

---

## API:

- Layout (`width`, `height`, `margin`, `padding`)
- Colors (`bacground`, `color`)
- Borders (`border`),
- HTML elements (`p`, `span`, `label`)

---

<LiveCode
	title="Box"
	code={require('!raw-loader!./code/Box.js').default}
	size="fullscreen"
/>

---

<Secondary>

# Flex

</Secondary>

---

## Flexbox layout

```jsx
<Flex
	alignItems="center"
	justifyContent="center"
	flexDirection="row"
	flexWrap="wrap"
/>
```

---

<LiveCode
	title="Box"
	code={require('!raw-loader!./code/Flex.js').default}
	size="fullscreen"
/>

---

<Secondary>

# Grid

</Secondary>

---

<Secondary>

# Stack

</Secondary>

---

<Secondary>

# Group

</Secondary>

---

<Boom>

> Primitives should not have any whitespace around them!

</Boom>

---

# Recap

- Start with primitive components (Text, Box)
- Use layout primitives to control the white space (Flex, Grid, Stack, Group, ...)
- Components should not have any whitespace around them
- Make primitives work with your design system, not just any values
- Embrace CSS knowledge when designing primitives
- Do not make any assumptions about where your components are going to be used

---

<Boom>

> The way your component library is built will inevitably affect the quality of the application code.

</Boom>

---

### Building UIs with primitives & patterns

1. Get a ~~static mockup~~ wireframe from a designer
1. Get data from API endpoint
1. Assembly UI using primitives or re-use a pattern.
1. ...
1. Profit

---

<Image src="../assets/napkin.jpg" size="contain" />

---

<Image src="../assets/wireframe.jpg" size="contain" />

---
